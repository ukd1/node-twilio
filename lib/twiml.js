var util = require('util'),
    EventEmitter = require('events').EventEmitter;

/**
 * Verb 'virtual' class. Base class for all Twiml verbs.
 * Verb defines three methods for all subclasses:
 * Verb.append(node): Append a node to the body of this node
 * Verb.attr(attr, val): Add an XML attribute called attr with value val to this node
 * Verb.toString: Render this node (and all contained nodes) as valid XML.
 */
function Verb(body, attrs) {
    this.body = body || [];
    this.attrs = attrs || {};

    this.verifyBody = function() {
        if(typeof this.body == 'object' && this.body.length > 0) {
            for(var i = 0; i < this.body.length; i++) {
                var curNode = this.body[i];
                
                if(!this.nestable[curNode.type]) {
                    throw new Error('Can not nest ' + node.type + 
                        ' Verb in ' + this.type + 'verb');
                }
            }
        }
    };
    
    this.append = function(node) {
        if(!this.body) {
            this.body = [];
        }

        this.body.push(node);
        this.verifyBody();
        return this;
    };
    
    this.attr = function(attr, value) {
        this.attrs[attr] = value;
    };
    
    this.toString = function(depth) {
        var stringified = '';

        depth = depth || 0;

        for(var j = 0; j < depth; j++) {
            stringified += '\t';
        }

        stringified += '<' + this.type;

        function quoteAttribute(attr) {
            if(attr[0] != '"') {
                return '"' + attr + '"';
            }
            return attr;
        }

        for(var key in this.attrs) {
            stringified += ' ' + key + '=' + quoteAttribute(this.attrs[key]);
        }

        if(this.body.length > 0) {
            stringified += '>\n';

            if(typeof this.body == 'string') {
                for(var i = 0; i < depth + 1; i++) {
                    stringified += '\t';
                }

                stringified += this.body;
            } else {
                for(var k = 0; k < this.body.length; k++) {
                    stringified += this.body[k].toString(depth + 1);
                }
            }
            stringified += '\n';
            for(var l = 0; l < depth; l++) {
                stringified += '\t';
            }
            stringified += '</' + this.type + '>';
        } else {
            // Self-clsoing tag
            stringified += '/>';
        }
        return stringified;
    };

    this.verifyBody();
}

/**
 * Say class. Represents a Twilio <Say> element.
 * See: http://www.twilio.com/docs/api/2010-04-01/twiml/say
 *
 * @param {String} body: (Required) The text to say
 * @param {Map} attrs: (Optional) Attributes for the xml object.
 *
 * (new Twiml.Say('Hello', {voice: 'man', language: 'en'})).toString() returns:
 *
 * <Say voice="main" lanugage="en">
 *     Hello
 * </Say>
 *
 */
var Say = module.exports.Say = function Say(body, attrs) {
    if(!body) {
        throw new Error('Say requires a body arg.');
    }
    
    this.type = 'Say';
    this.nestable = {};
    
    Verb.call(this, body, attrs);
};

/**
 * Play class. Represents a Twilio <Play> element.
 * See: http://www.twilio.com/docs/api/2010-04-01/twiml/play
 *
 * @param {String} body: (Required) The URI of the file to play
 * @param {Map} attrs: (Optional) Attributes for this XML element.
 *
 * (new Twiml.Play('http://mp3.com/', {loop: 2})).toString() returns:
 * 
 * <Play loop="2">
 *       http://mp3.com/
 * </Play>
 */
var Play = module.exports.Play = function Play(body, attrs) {
    if(!body) {
        throw new Error('Play requires a body (uri to play)');
    }
    
    this.type = 'Play';
    this.nestable = {};

    Verb.call(this, body, attrs);
};

/**
 * Gather glass. Represents a Twiml <Gather> element.
 * See: http://www.twilio.com/docs/api/2010-04-01/twiml/gather
 *
 * @param {Mixed} body: (Optional) Either a Play, Say, or Pause element.
 * @param {Map} attrs: (Optional) Attributes for this XML element.
 *
 * var s = new Twiml.Say('Tell me your favourite number');
 * (new Twiml.Gather(p, {maxDigits: 2})).toString() returns:
 *
 * <Gather maxDigits="2">
 *     <Say>
 *          Tell me your favourite number
 *     </Say>
 * </Gather>
 *
 * When a gather object is instantied without an 'action' attribute
 * and when the global autoURI object is available (which is available
 * whenever using the high-level API), then this object becomes an
 * event emitter.
 *
 * @event 'gathered': Fired when Twilio has queried the gather URI
 * generated by AutoUri.
 * Example:
 *     var p = new Gather(); // Empty Gather, which is valid
 *     p.on('gathered', function(reqParams, res) {
 *         // Here, reqParams is the posted data from Twilio's request
 *         // and Response is a Twiml.Response object.
 *         // With 'Gathers', Twilio's request includes a Digits param
 *         // that contains the digits the user entered.
 *         console.log('User pressed: ' + reqParams.Digits);
 *     });
 */
var Gather = module.exports.Gather = function Gather(body, attrs) {
    var self = this;

    this.type = 'Gather';
    this.nestable = {
        Play: true,
        Say: true,
        Pause: true
    };

    if(typeof body == 'string') {
        throw new Error('Gather only accepts Play, Say, or Pause bodies');
    }

    attrs = attrs || {};

    Verb.call(this, body ? [body] : null, attrs);
    EventEmitter.call(this);
    
    if(!attrs.action && global.autoUri) {
        // No action specified, let's emit events!
        var uri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('gathered', req.body, new Response(res));
        }, {maxRequests: 1});
        this.attrs.action = uri;
        this.attrs.method = 'POST';
    }
};

util.inherits(Gather, EventEmitter);

/**
 * Record class. Represents a Twiml <Record> element.
 * See: http://www.twilio.com/docs/api/2010-04-01/twiml/record
 *
 * @param {Map} attrs: (Optional) A map of XML attributes for this element.
 *
 * Record is an event emitter just like gather.
 *
 * @event 'recorded': Fired when Twilio has requested the auto-generated action
 * uri for this element.
 *
 * Example:
 *    var r = new Twiml.Record({timeout: 10});
 *    r.on('recorded', function(reqParam, res) {
 *        // Just like with gather, reqParams are the Twilio request's params
 *        // and res is a Twiml.Response object.
 *        // Twilio will send a RecordingUrl parameter with the URL of the recording.
 *        console.log('Recording is at: ' + reqParams.RecordingUrl);
 *    });
 */
var Record = module.exports.Record = function Record(attrs) {
    var self = this, uri;

    this.type = 'Record';
    this.nestable = {};
    
    attrs = attrs || {};

    Verb.call(this, null, attrs);
    EventEmitter.call(this);
    
    if(!attrs.action && global.autoUri) {
        uri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('recorded', req.body, new Response(res));
        }, {maxRequests: 1});
        this.attrs.action = uri;
        this.attrs.method = 'POST';
    }
    if (attrs.transcribe && global.autoUri) { 
        uri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('transcribed', req.body, new Response(res));
        }, {maxRequests: 1});
        this.attrs.transcribeCallback = uri;
        this.attrs.method = 'POST';
    }
};

util.inherits(Record, EventEmitter);

var Sms = module.exports.Sms = function Sms(body, attrs) {
    var self = this;
    
    if(!body) {
        throw new Error('Sms verb requires body argument');
    }

    this.type = 'Sms';
    this.nestable = {};
    
    attrs = attrs || {};

    Verb.call(this, body, attrs);
    EventEmitter.call(this);

    if(!attrs.action && global.autoUri) {
        var queuedUri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('enqueued', req.body, new Response(res));
        }, {maxRequests: 1});
        var statusUri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('status', req.body, new Response(res));
        });
        this.attrs.action = queuedUri;
        this.attrs.method = 'POST';
        this.attrs.statusCallback = statusUri;
    }
};

util.inherits(Sms, EventEmitter);

var Dial = module.exports.Dial = function Dial(body, attrs) {
    var self = this;
    
    this.type = 'Dial';
    this.nestable = {
        Number: true,
		Client: true,
        Conference: true
    };
    
    attrs = attrs || {};

    Verb.call(this, body, attrs);
    EventEmitter.call(this);

    if(!attrs.action && global.autoUri) {
        var uri = global.autoUri.addCallback('POST', function(req, res) {
            self.emit('callEnded', req.body, new Response(res));
        }, {maxRequests: 1});
        this.attrs.action = uri;
        this.attrs.method = 'POST';
    }
};

util.inherits(Dial, EventEmitter);

var Num = module.exports.Num = function Num(body, attrs) {
    if(!body) {
        throw new Error('Num noun requires body argument');
    }

    this.type = 'Number';
    this.nestable = {};
    
    Verb.call(this, body, attrs);
};

var Cli = module.exports.Cli = function Cli(body) {
	if (!body) {
		throw new Error('Client noun requires body argument');
	}
	
	this.type = 'Client';
	this.nestable = {};
	
	Verb.call(this, body, null);
}

var Conference = module.exports.Conference = function Conference(body, attrs) {
    if(!body) {
        throw new Error('Conference noun requires body argument');
    }

    this.type = 'Conference';
    this.nestable = {};
    
    Verb.call(this, body, attrs);
};

var Hangup = module.exports.Hangup = function Hangup(attrs) {
    this.type = 'Hangup';
    this.nestable = {};

    Verb.call(this, null, attrs);
};

var Redirect = module.exports.Redirect = function Redirect(uri, attrs) {
    if(!uri) {
        throw new Error('Redirect requires a uri argument');
    }

    this.type = 'Redirect';
    this.nestable = {};
    
    Verb.call(this, uri, attrs);
};

var Reject = module.exports.Reject = function Reject(attrs) {
    this.type = 'Reject';
    this.nestable = {};

    Verb.call(this, null, attrs);
};

var Pause = module.exports.Pause = function Pause(attrs) {
    this.type = 'Pause';
    this.nestable = {};

    Verb.call(this, null, attrs);
};

var Response = module.exports.Response = function Response(res) {
    this.res = res;
    this.body = [];
    
    this.append = function(node) {
        this.body.push(node);
        return this;
    };

    this.toString = function() {
        var str = '<?xml version="1.0" encoding="UTF-8"?>\n<Response>\n';
        for(var i = 0; i < this.body.length; i++) {
            str += this.body[i].toString(1) + '\n';
        }
        str += '</Response>\n';
        return str;
    };

    this.send = function() {
        this.res.send(this.toString());
    };
};
